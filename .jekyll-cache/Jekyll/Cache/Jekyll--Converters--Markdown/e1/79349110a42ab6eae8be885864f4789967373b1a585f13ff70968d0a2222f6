I"«<p>Ein gro√üer Bestandteil in der JavaScript-Programmierung ist die Behandlung von Web-Requests und dessen Responses. Da dies meist in Echtzeit passiert, ist es unerl√§sslich einen asynchronen Abarbeitungsfluss zu programmieren. Das bedeutet, man kann die Antwort eines Requests erst verarbeiten, wenn die Antwort auch da ist. In diesen Notizen sollen die asynchronen Prozessabl√§ufe in JavaScript festgehalten werden.</p>

<h3 id="synchron-vs-asynchron">Synchron vs. Asynchron</h3>

<p>Ein synchroner Prozessablauf ist ein standardm√§√üiges Programm, welches Zeile f√ºr Zeile abgearbeitet wird. Es gibt dabei nur einen einzelnen Thread, welcher im Browser abgearbeitet wird. Im Gegensatz dazu, versucht man mit einem asynchronen Prozessablauf, bestimmten Code im Hintergrund laufen zu lassen bis ein Ergebnis berechnet wurde. Daf√ºr √ºbergibt man meist eine Callback-Funktion, die bei Fertigstellung aufgerufen wird. So wird das Programm an keiner Stelle blockiert, sondern l√§uft nahtlos weiter.</p>

<h3 id="promises">Promises</h3>

<p>Ein <strong>Promise</strong> ist ein Objekt, welches den √úberblick dar√ºber beh√§lt, ob ein Event bereits abgeschlossen ist oder nicht. Au√üerdem entscheidet das Objekt, was passieren soll, wenn das zu √ºberwachende Event abgeschlossen ist. Dabei beinhaltet das <strong>Promise</strong> den Wert, der vom Event zur√ºckgegeben wird.</p>

<p>Dadurch, dass ein Promise davon abh√§ngt, ob ein Event abgeschlossen ist, gibt es auch unterschiedliche Zust√§nde davon. Bevor ein Event ausgel√∂st wird, ist ein Promise noch im Zustand <em>Wartend (Pending)</em>. Ist das Event dann abgeschlossen, ist das Promise im Zustand <em>Erledigt/Gel√∂st (Settled/Resolved)</em>. Je nachdem, ob das Event erfolgreich war, ist das Promise in einem anderen Zustand nachdem das Event erledigt wurde. Wenn das Event erfolgreich abgeschlossen wurde, ist das Promise im Zustand <em>Erf√ºllt (Fulfilled)</em>. Falls ein Fehler auftritt ist, es im Zustand <em>Zur√ºckgewiesen (Rejected)</em>.</p>

<p>Durch diesen Zustandsgraphen ergibt sich auch ein bestimmter Terminus, wie Promise genutzt werden. Wird ein Promise angelegt, wird es <strong>produziert</strong>. Das bedeutet, man legt es an, ohne den Ausgangswert zu kennen. Wenn der Ausgangswert klar ist, kann dieses Promise <strong>konsumiert</strong> werden.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getIds</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span>
      <span class="p">[</span><span class="mi">239</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">994</span><span class="p">,</span> <span class="mi">122</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>
    <span class="p">);</span>
  <span class="p">},</span> <span class="mi">1500</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">getIds</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">ids</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ids</span><span class="p">);</span>
	<span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Error!</span><span class="dl">'</span><span class="p">);</span>
	<span class="p">});</span>
</code></pre></div></div>

<h3 id="asyncawait">Async/Await</h3>

<p>In ES8 (ES2017) wurde eine neue Syntax eingef√ºhrt, um das konsumieren von Promises zu vereinfachen. Mit dem <strong>async</strong> Schl√ºsselwort k√∂nnen asynchrone Funktionen deklariert werden, in welchen das <strong>await</strong> Schl√ºsselwort genutzt werden kann. Mit diesem Schl√ºsselwort wartet der Prozess, bis das Promise, auf welches gewartet wird, im Status <em>Erledigt</em> ist.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">getRecipesAW</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">ids</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getIds</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">recipe</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getRecipe</span><span class="p">(</span><span class="nx">ids</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">related</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getRelated</span><span class="p">(</span><span class="nx">recipe</span><span class="p">.</span><span class="nx">publisher</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">related</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">getRecipesAW</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
</code></pre></div></div>
:ET